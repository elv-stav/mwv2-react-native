/** Declaration file generated by dts-gen */
declare module "@eluvio/elv-client-js" {
  import { Dict } from "@/utils/Dict";

  export class ElvClient {
    constructor(...args: any[]);

    AccessGroupManagers({ contractAddress }: any): any;

    AccessGroupMembers({ contractAddress }: any): any;

    AccessGroupMembershipMethod({
                                  contractAddress,
                                  memberAddress,
                                  methodName,
                                  eventName
                                }: any): any;

    AccessGroupOwner({ contractAddress }: any): any;

    AccessInfo({ objectId, args }: any): any;

    AccessRequest({ libraryId, objectId, versionHash, args = [], update = false, noCache = false }: any): any;

    AccessType({ id }: any): any;

    AddAccessGroupManager({ contractAddress, memberAddress }: any): any;

    AddAccessGroupMember({ contractAddress, memberAddress }: any): any;

    AddContentLibraryGroup({ libraryId, groupAddress, permission }: any): void;

    AddContentObjectGroupPermission({ objectId, groupAddress, permission }: any): any;

    AddLibraryContentType({ libraryId, typeId, typeName, typeHash, customContractAddress }: any): any;

    AssetMetadata({
                    libraryId,
                    objectId,
                    versionHash,
                    metadata,
                    localization,
                    noAuth,
                    produceLinkUrls = false
                  }: any): any;

    AuditContentObject({ libraryId, objectId, versionHash, salt, samples, authorizationToken }: any): any;

    AuditStream({ objectId, versionHash, salt, samples, authorizationToken }: any): any;

    AvailableDRMs(): any;

    AvailableOfferings({
                         objectId,
                         versionHash,
                         writeToken,
                         linkPath,
                         signedLink,
                         directLink,
                         handler = "playout",
                         authorizationToken
                       }: any): any;

    AwaitPending(objectId: any): void;

    BitmovinPlayoutOptions({
                             objectId,
                             versionHash,
                             writeToken,
                             linkPath,
                             signedLink = false,
                             protocols = ["dash", "hls"],
                             drms = [],
                             handler = "playout",
                             offering = "default",
                             playoutType,
                             context,
                             authorizationToken,
                             options = {}
                           }: any): any;

    BlockNumber(): any;

    CallBitcodeMethod({
                        libraryId,
                        objectId,
                        versionHash,
                        writeToken,
                        method,
                        queryParams = {},
                        body = {},
                        headers = {},
                        constant = true,
                        format = "json"
                      }: any): any;

    CallContractMethod({
                         contractAddress,
                         abi,
                         methodName,
                         methodArgs = [],
                         value,
                         overrides = {},
                         formatArguments = true,
                         cacheContract = true,
                         overrideCachedContract = false
                       }: any): any;

    CallContractMethodAndWait({
                                contractAddress,
                                abi,
                                methodName,
                                methodArgs,
                                value,
                                overrides = {},
                                formatArguments = true,
                                cacheContract = true,
                                overrideCachedContract = false
                              }: any): any;

    CallFromFrameMessage(...args: any[]): void;

    ClearCache(...args: any[]): void;

    ClearSigner(...args: any[]): void;

    ClearStaticToken(...args: any[]): void;

    Collection({ collectionType }: any): any;

    CollectionTransactions({ tenantId, collectionId, filterOptions = {} }: any): any;

    ConfigUrl(...args: any[]): void;

    ContentLibraries(): any;

    ContentLibrary({ libraryId }: any): any;

    ContentLibraryGroupPermissions({ libraryId, permissions = [] }: any): any;

    ContentLibraryOwner({ libraryId }: any): any;

    ContentObject({ libraryId, objectId, versionHash, writeToken }: any): any;

    ContentObjectAccessComplete({ objectId, score = 100 }: any): any;

    ContentObjectGraph({ libraryId, objectId, versionHash, autoUpdate = false, select }: any): any;

    ContentObjectGroupPermissions({ objectId }: any): any;

    ContentObjectImageUrl({ libraryId, objectId, versionHash, height, imagePath = "public/display_image" }: any): any;

    ContentObjectLibraryId({ objectId, versionHash }: any): any;

    ContentObjectMetadata({
                            libraryId,
                            objectId,
                            versionHash,
                            writeToken,
                            metadataSubtree = "/",
                            localizationSubtree,
                            queryParams = {},
                            select = [],
                            remove = [],
                            authorizationToken,
                            noAuth = false,
                            resolveLinks = false,
                            resolveIncludeSource = false,
                            resolveIgnoreErrors = false,
                            linkDepthLimit = 1,
                            produceLinkUrls = false,
                          }: any, ...args: any[]): any;

    ContentObjectOwner({ objectId }: any): any;

    ContentObjectTenantId({ objectId, versionHash }: any): any;

    ContentObjectVersions({ libraryId, objectId }: any): any;

    ContentObjects({ libraryId, filterOptions = {} }: any): any;

    ContentPart({ libraryId, objectId, versionHash, partHash }: any): any;

    ContentParts({ libraryId, objectId, versionHash }: any): any;

    ContentSpaceId(): any;

    ContentType({ name, typeId, versionHash, publicOnly = false }: any): any;

    ContentTypeOwner({ name, typeId, versionHash }: any): any;

    ContentTypes(): any;

    ContractAbi({ contractAddress, id }: any): any;

    ContractEvents({
                     contractAddress,
                     abi,
                     fromBlock = 0,
                     toBlock,
                     count = 1000,
                     topics,
                     includeTransaction = false
                   }: any): any;

    ContractInfo({ id, address }: any): any;

    ContractMetadata({ contractAddress, metadataKey, }: any): any;

    ContractName({ contractAddress }: any): any;

    CopyContentObject({ libraryId, originalVersionHash, options = {} }: any): any;

    CreateABRMezzanine({
                         libraryId,
                         objectId,
                         type,
                         name,
                         description,
                         metadata,
                         masterVersionHash,
                         abrProfile,
                         addlOfferingSpecs,
                         variant = "default",
                         offeringKey = "default",
                         keepOtherStreams = false,
                         respLogLevel = "warn",
                         structLogLevel = "none",
                         streamKeys
                       }: any): any;

    CreateAccessGroup({ name, description, metadata = {}, visibility = 1 }: any): any;

    CreateAccount(...args: any[]): void;

    CreateAndFinalizeContentObject({
                                     libraryId,
                                     callback,
                                     options = {},
                                     commitMessage = "",
                                     publish = true,
                                     awaitCommitConfirmation = true
                                   }: any): any;

    CreateAuthorizationToken(...args: any[]): void;

    CreateContentLibrary({
                           name,
                           description,
                           image,
                           imageName,
                           metadata = {},
                           kmsId,
                           tenantContractId
                         }: any): any;

    CreateContentObject({ libraryId, objectId, options = {} }: any): any;

    CreateContentType({ name, metadata = {}, bitcode }: any): any;

    CreateEncryptionConk({ libraryId, objectId, versionHash, writeToken, createKMSConk = true }: any): any;

    CreateFabricToken(...args: any[]): void;

    CreateFileDirectories({ libraryId, objectId, writeToken, filePaths }: any): void;

    CreateFileUploadJob({ libraryId, objectId, writeToken, ops, defaults = {}, encryption = "none" }: any): any;

    CreateLinks({
                  libraryId,
                  objectId,
                  writeToken,
                  links = []
                }: any): void;

    CreateNTPInstance({
                        tenantId,
                        objectId,
                        groupAddresses,
                        ntpClass = 4,
                        maxTickets = 0,
                        maxRedemptions = 100,
                        startTime,
                        endTime,
                        ticketLength = 6
                      }: any): any;

    CreateNonOwnerCap({ objectId, libraryId, publicKey, writeToken }: any): void;

    CreatePart({ libraryId, objectId, writeToken, encryption }: any): any;

    CreateProductionMaster({
                             libraryId,
                             type,
                             name,
                             description,
                             metadata = {},
                             fileInfo,
                             encrypt = true,
                             access = [],
                             copy = false,
                             callback,
                             respLogLevel = "warn",
                             structLogLevel = "none"
                           }: any): any;

    CreateShare({ objectId, expiresAt, params = {} }: any): any;

    CreateSignedMessageJSON(...args: any[]): void;

    CreateSignedToken(...args: any[]): void;

    CreateStaticToken(...args: any[]): void;

    CurrentAccountAddress(...args: any[]): void;

    CustomContractAddress({ libraryId, objectId, versionHash }: any): any;

    DecodeSignedMessageJSON(...args: any[]): void;

    Decrypt({ libraryId, objectId, writeToken, chunk }: any): any;

    DecryptECIES(...args: any[]): void;

    DefaultKMSAddress({ tenantId }: any): any;

    DeleteAccessGroup({ contractAddress }: any): void;

    DeleteContentLibrary({ libraryId }: any): void;

    DeleteContentObject({ libraryId, objectId }: any): void;

    DeleteContentVersion({ versionHash }: any): void;

    DeleteFiles({ libraryId, objectId, writeToken, filePaths }: any): void;

    DeleteMetadata({ libraryId, objectId, writeToken, metadataSubtree = "/" }: any): void;

    DeleteNTPInstance({ tenantId, ntpId }: any): void;

    DeletePart({ libraryId, objectId, writeToken, partHash }: any): void;

    DeleteWriteToken({ writeToken, libraryId }: any): void;

    DeployContract({ abi, bytecode, constructorArgs, overrides = {} }: any): any;

    Download({
               downloadPath,
               headers,
               bytesTotal,
               chunked = false,
               chunkSize = 2000000,
               callback,
               format = "arrayBuffer"
             }: any): any;

    DownloadEncrypted({
                        conk,
                        downloadPath,
                        bytesTotal,
                        headers,
                        callback,
                        format = "arrayBuffer",
                        chunked = false
                      }: any): any;

    DownloadFile({
                   libraryId,
                   objectId,
                   versionHash,
                   writeToken,
                   filePath,
                   format = "arrayBuffer",
                   chunked = false,
                   chunkSize,
                   clientSideDecryption = false,
                   callback
                 }: any, ...args: any[]): any;

    DownloadPart({
                   libraryId,
                   objectId,
                   versionHash,
                   writeToken,
                   partHash,
                   format = "arrayBuffer",
                   chunked = false,
                   chunkSize = 10000000,
                   callback
                 }: any): any;

    EditAndFinalizeContentObject({
                                   libraryId,
                                   objectId,
                                   callback,
                                   options = {},
                                   commitMessage = "",
                                   publish = true,
                                   awaitCommitConfirmation = true
                                 }: any): any;

    EditContentObject({ libraryId, objectId, options = {} }: any): any;

    EmbedUrl({
               objectId,
               versionHash,
               duration = 86400000,
               mediaType = "video",
               options = {},
               additionalParameters = {}
             }: any): any;

    EnableMethodLogging(...args: any[]): void;

    Encrypt({ libraryId, objectId, writeToken, chunk }: any): any;

    EncryptECIES(...args: any[]): void;

    EncryptionConk({ libraryId, objectId, versionHash, writeToken, download = false }: any): any;

    Events({ toBlock, fromBlock, count = 10, includeTransaction = false }: any): any;

    ExtractEventFromLogs({ abi, event, eventName }: any): any;

    ExtractValueFromEvent({ abi, event, eventName, eventValue }: any): any;

    FabricUrl({
                libraryId,
                objectId,
                versionHash,
                writeToken,
                partHash,
                rep,
                publicRep,
                call,
                queryParams = {},
                service = "fabric",
                channelAuth = false,
                makeAccessRequest = false,
                noAuth = false,
                noCache = false
              }: any): any;

    FileUrl({}: {
      libraryId?: string,
      objectId?: string,
      versionHash?: string,
      writeToken?: string,
      filePath?: string,
      queryParams?: Dict<any>,
      noCache?: boolean
    }): Promise<string>;

    FinalizeABRMezzanine({ libraryId, objectId, preFinalizeFn, preFinalizeThrow }: any): any;

    FinalizeContentObject({
                            libraryId,
                            objectId,
                            writeToken,
                            commitMessage = "",
                            publish = true,
                            awaitCommitConfirmation = true
                          }: any): any;

    FinalizePart({ libraryId, objectId, writeToken, partWriteToken, encryption }: any): any;

    FinalizeStateChannelAccess({ objectId, versionHash, percentComplete }: any): void;

    FinalizeUploadJob({ libraryId, objectId, writeToken }: any): void;

    FormatBlockNumbers({ fromBlock, toBlock, count = 10 }: any): any;

    FormatContractArguments({ abi, methodName, args }: any): any;

    FrameAllowedMethods(...args: any[]): void;

    GenerateSignedLinkToken({
                              containerId,
                              versionHash,
                              link,
                              duration
                            }: any): any;

    GenerateStateChannelToken({ objectId, versionHash, context, noCache = false }: any): any;

    GenerateWallet(...args: any[]): void;

    GetBalance({ address }: any): any;

    GlobalUrl({
                libraryId,
                objectId,
                writeToken,
                versionHash,
                path = "/",
                authorizationToken,
                noAuth = false,
                resolve = true,
                queryParams = {}
              }: any): any;

    InitializeAuthPolicy({
                           libraryId,
                           objectId,
                           writeToken,
                           target = "auth_policy_spec",
                           body,
                           version,
                           description,
                           id
                         }: any): void;

    InitializeClients(...args: any[]): void;

    IssueNTPCode({ tenantId, ntpId, email, maxRedemptions }: any): any;

    IssueSignedNTPCode({ tenantId, ntpId, email, maxRedemptions }: any): any;

    LRODraftInfo({ libraryId, objectId }: any): any;

    LROStatus({ libraryId, objectId }: any): any;

    LatestVersionHash({ objectId, versionHash }: { objectId?: string, versionHash?: string }): Promise<string>;

    LatestVersionHashV2({ objectId, versionHash }: any): any;

    LibraryContentTypes({ libraryId }: any): any;

    LinkAccessGroupToOauth({ groupAddress, kmsId, oauthConfig }: any): void;

    LinkData({
               libraryId,
               objectId,
               versionHash,
               writeToken,
               linkPath,
               queryParams = {},
               format = "json",
               channelAuth
             }: any): any;

    LinkTarget({ libraryId, objectId, versionHash, writeToken, linkPath, authorizationToken, linkInfo }: any): any;

    LinkUrl({}: {
      libraryId?: string,
      objectId?: string,
      versionHash?: string,
      writeToken?: string,
      linkPath?: string,
      mimeType?: string,
      authorizationToken?: string,
      queryParams?: Dict<any>,
      channelAuth?: boolean,
      noAuth?: boolean
    }): Promise<string>;

    ListAccessGroups(): any;

    ListFiles({ libraryId, objectId, path = "", versionHash, writeToken }: any): any;

    ListNTPInstances({ tenantId, count = 10, offset = 0 }: any): any;

    Log(...args: any[]): void;

    MakeAuthServiceRequest(...args: any[]): void;

    MakeFileServiceRequest({
                             libraryId,
                             objectId,
                             versionHash,
                             writeToken,
                             path,
                             method = "GET",
                             queryParams = {},
                             body,
                             bodyType = "JSON",
                             format = "json",
                             encryption,
                             headers = {},
                             authorizationToken
                           }: any): any;

    MergeContractMetadata({ contractAddress, metadataKey, metadata }: any): void;

    MergeMetadata({ libraryId, objectId, writeToken, metadataSubtree = "/", metadata = {} }: any): void;

    MetadataAuth({
                   libraryId,
                   objectId,
                   versionHash,
                   path = "/",
                   channelAuth = false,
                   noAuth = false
                 }: any): any;

    MintNFT({ tenantId, address, marketplaceId, items, extraData = {} }: any): any;

    MoveFiles({ libraryId, objectId, writeToken, filePaths }: any): void;

    NTPInstance({ tenantId, ntpId }: any): any;

    NetworkInfo(...args: any[]): void;

    NodeId(...args: any[]): void;

    Nodes(...args: any[]): void;

    Permission({ objectId, clearCache }: any): any;

    PersonalSign(...args: any[]): void;

    PlayoutOptions({
                     offeringURI,
                     objectId,
                     versionHash,
                     writeToken,
                     linkPath,
                     signedLink = false,
                     protocols = ["dash", "hls"],
                     handler = "playout",
                     offering = "default",
                     playoutType,
                     drms = [],
                     context,
                     hlsjsProfile = true,
                     authorizationToken,
                     options = {}
                   }: any): any;

    PlayoutPathResolution({
                            libraryId,
                            objectId,
                            versionHash,
                            writeToken,
                            linkPath,
                            handler,
                            offering = "",
                            signedLink = false,
                            authorizationToken
                          }: any): any;

    ProduceMetadataLinks({
                           libraryId,
                           objectId,
                           versionHash,
                           path = "/",
                           metadata,
                           authorizationToken,
                           noAuth
                         }: any): any;

    Proofs({ libraryId, objectId, versionHash, partHash }: any): any;

    PublicRep({ libraryId, objectId, versionHash, rep, queryParams = {}, service = "fabric" }: any): any;

    PublishContentVersion({ objectId, versionHash, awaitCommitConfirmation = true }: any): void;

    QParts({ libraryId, objectId, partHash, format = "blob" }: any): any;

    RecordWriteToken(...args: any[]): void;

    RedeemCode({ issuer, tenantId, ntpId, code, email, includeNTPId = false }: any): any;

    RedeemShareToken({ shareId }: any): any;

    RemoveAccessGroupManager({ contractAddress, memberAddress }: any): any;

    RemoveAccessGroupMember({ contractAddress, memberAddress }: any): any;

    RemoveContentLibraryGroup({ libraryId, groupAddress, permission }: any): void;

    RemoveContentObjectGroupPermission({ objectId, groupAddress, permission }: any): any;

    RemoveLibraryContentType({ libraryId, typeId, typeName, typeHash }: any): any;

    Rep({
          libraryId,
          objectId,
          versionHash,
          writeToken,
          rep,
          queryParams = {},
          service = "fabric",
          makeAccessRequest = false,
          channelAuth = false,
          noAuth = false,
          noCache = false
        }: any): any;

    ReplaceContractMetadata({ contractAddress, metadataKey, metadata }: any): void;

    ReplaceMetadata({ libraryId, objectId, writeToken, metadataSubtree = "/", metadata = {} }: any): void;

    Request(...args: any[]): void;

    ResetRegion(...args: any[]): void;

    ResetTenantId({ contractAddress, objectId, versionHash }: any): void;

    RevokeShare({ shareId }: any): any;

    SendFunds({ recipient, ether }: any): any;

    SetAccessCharge({ objectId, accessCharge }: any): void;

    SetAuth(...args: any[]): void;

    SetAuthContext({ context }: any): void;

    SetAuthPolicy({ objectId, policyId }: any): void;

    SetContentLibraryImage({ libraryId, writeToken, image, imageName }: any): any;

    SetContentObjectImage({
                            libraryId,
                            objectId,
                            writeToken,
                            image,
                            imageName,
                            imagePath = "public/display_image"
                          }: any): void;

    SetCustomContentContract({
                               libraryId,
                               objectId,
                               customContractAddress,
                               name,
                               description,
                               abi,
                               factoryAbi,
                               overrides = {}
                             }: any): any;

    SetGroupPermission({ groupAddress, objectId, permission, remove = false }: any): any;

    SetNodes(...args: any[]): void;

    SetOauthToken(...args: any[]): void;

    SetPermission({ objectId, permission, writeToken }: any): void;

    SetPolicyAuthorization(...args: any[]): void;

    SetRemoteSigner(...args: any[]): void;

    SetSigner(...args: any[]): void;

    SetSignerFromOauthToken(...args: any[]): void;

    SetSignerFromWeb3Provider(...args: any[]): void;

    SetStaticToken(...args: any[]): void;

    SetTenantContractId({ contractAddress, objectId, versionHash, tenantContractId }: any): any;

    SetTenantId({ contractAddress, objectId, versionHash, tenantId }: any): any;

    SetVisibility({ id, visibility }: any): any;

    ShareInfo({ shareId }: any): any;

    Shares({ objectId, limit = 100, offset = 0, params = {} }: any): any;

    Sign(...args: any[]): void;

    SpaceNodes(...args: any[]): void;

    StartABRMezzanineJobs({
                            libraryId,
                            objectId,
                            access = [],
                            jobIndexes = null
                          }: any): any;

    StreamAddWatermark({
                         libraryId,
                         objectId,
                         writeToken,
                         simpleWatermark,
                         imageWatermark,
                         forensicWatermark,
                         finalize = true
                       }: any): any;

    StreamConfig({
                   name,
                   customSettings = {},
                   probeMetadata,
                   writeToken,
                   finalize = true
                 }: any): any;

    StreamCopyToVod({
                      name,
                      targetObjectId,
                      eventId,
                      streams = null,
                      finalize = true,
                      recordingPeriod = -1,
                      startTime = "",
                      endTime = ""
                    }: any): any;

    StreamCreate({ name, start = false }: any): any;

    StreamInitialize({ name, drm = false, format }: any): any;

    StreamInsertion({ name, insertionTime, sinceStart = false, duration, targetHash, remove = false }: any): any;

    StreamListUrls({ siteId }: any): any;

    StreamRemoveWatermark({
                            libraryId,
                            objectId,
                            writeToken,
                            types,
                            finalize = true
                          }: any): any;

    StreamSetOfferingAndDRM({ name, typeAbrMaster, typeLiveStream, drm = false, format }: any): any;

    StreamStartOrStopOrReset({ name, op }: any): any;

    StreamStatus({ name, stopLro = false, showParams = false }: any): any;

    StreamStopSession({ name }: any): any;

    SuspendNTPInstance({ tenantId, ntpId }: any): void;

    TenantContractId({ contractAddress, objectId, versionHash }: any): any;

    TenantId({ contractAddress, objectId, versionHash }: any): any;

    ToggleLogging(...args: any[]): void;

    UnlinkAccessGroupFromOauth({ groupAddress }: any): void;

    UpdateContentObjectGraph({ libraryId, objectId, versionHash, callback }: any): void;

    UpdateNTPInstance({
                        tenantId,
                        ntpId,
                        maxTickets = 0,
                        maxRedemptions = 100,
                        startTime,
                        endTime,
                      }: any): any;

    UpdateShare({ shareId, expiresAt, params = {} }: any): any;

    UploadFileData({ libraryId, objectId, writeToken, encryption, uploadId, jobId, filePath, fileData }: any): any;

    UploadFiles({ libraryId, objectId, writeToken, fileInfo, encryption = "none", callback }: any): void;

    UploadFilesFromS3({
                        libraryId,
                        objectId,
                        writeToken,
                        region,
                        bucket,
                        fileInfo,
                        accessKey,
                        secret,
                        signedUrl,
                        encryption = "none",
                        copy = false,
                        callback
                      }: any): any;

    UploadJobStatus({ libraryId, objectId, writeToken, uploadId, jobId }: any): any;

    UploadPart({
                 libraryId,
                 objectId,
                 writeToken,
                 data,
                 encryption = "none",
                 chunkSize = 10000000,
                 callback
               }: any): any;

    UploadPartChunk({ libraryId, objectId, writeToken, partWriteToken, chunk, encryption }: any): void;

    UploadStatus({ libraryId, objectId, writeToken, uploadId }: any): any;

    UseRegion(...args: any[]): void;

    Visibility({ id, clearCache }: any): any;

    WriteTokenNodeUrl(...args: any[]): void;

    static Configuration(...args: any[]): void;

    static FromConfigurationUrl({}: {
      configUrl: string,
      region?: string,
      clientIP?: string,
      trustAuthorityId?: string,
      staticToken?: string,
      ethereumContractTimeout?: number,
      noCache?: boolean,
      noAuth?: boolean,
      assumeV3?: boolean
    }): Promise<ElvClient>;

    static FromNetworkName({}: {
      networkName: string,
      region?: string,
      clientIP?: string,
      trustAuthorityId?: string,
      staticToken?: string,
      ethereumContractTimeout?: number,
      noCache?: boolean,
      noAuth?: boolean,
      assumeV3?: boolean,
    }): Promise<ElvClient>;

    static Networks(...args: any[]): void;

  }

  export class ElvWalletClient {
    loggedIn: boolean;
    client?: ElvClient;

    constructor(...args: any[]);

    AcceptMarketplaceOffer({ offerId }: any): any;

    AddNotificationListener({ onMessage }: any): any;

    AuthToken(...args: any[]): void;

    Authenticate(...args: any[]): void;

    AuthenticateExternalWallet(...args: any[]): void;

    AuthenticateOAuth(...args: any[]): void;

    AvailableMarketplaces({ organizeById, forceReload = false }: any): any;

    CanSign(...args: any[]): void;

    CastVote({ tenantId, votingEventId, sku }: any): any;

    ClaimGift({ code }: any): any;

    ClaimItem({ marketplaceParams, sku, email }: any): void;

    ClaimStatus({ marketplaceParams, sku }: any): any;

    ClientAuthToken(...args: any[]): void;

    CollectionRedemptionStatus({ marketplaceParams, confirmationId }: any): any;

    CreateListing({ contractAddress, tokenId, price, listingId }: any): any;

    CreateMarketplaceOffer({ contractAddress, tokenId, offerId, price, expiresAt }: any): any;

    DeployTenant(...args: any[]): void;

    DropStatus({ marketplace, eventId, dropId }: any): any;

    EntitlementClaimStatus({ marketplaceParams, purchaseId }: any): any;

    ExchangeRate({ currency }: any): any;

    FilteredQuery(...args: any[]): void;

    FlowURL(...args: any[]): void;

    GenerateCodeAuth(...args: any[]): void;

    GetCodeAuth(...args: any[]): void;

    GiftClaimStatus({ marketplaceParams, confirmationId, giftId }: any): any;

    LatestMarketplaceHash(...args: any[]): void;

    Leaderboard({ userAddress, marketplaceParams }: any, ...args: any[]): any;

    Listing({ listingId }: any): any;

    ListingAttributes({ marketplaceParams, displayName }: any): any;

    ListingEditionNames({ displayName }: any): any;

    ListingNames({ marketplaceParams }: any): any;

    ListingPurchaseStatus({ listingId, confirmationId }: any): any;

    ListingStats(...args: any[]): any;

    ListingStatus({ listingId }: any): any;

    Listings(...args: any[]): any;

    LoadAvailableMarketplaces(...args: any[]): void;

    LoadDrop({ tenantSlug, eventSlug, dropId }: any): any;

    LoadMarketplace(...args: any[]): void;

    Log(...args: any[]): void;

    LogIn(...args: any[]): void;

    LogInURL(...args: any[]): void;

    LogOut(): Promise<void>;

    Marketplace({ marketplaceParams }: any): any;

    MarketplaceCSS({ marketplaceParams }: any): any;

    MarketplaceInfo({ marketplaceParams }: any, ...args: any[]): any;

    MarketplaceOffers({
                        contractAddress,
                        tokenId,
                        buyerAddress,
                        sellerAddress,
                        statuses,
                        start = 0,
                        limit = 10
                      }: any): any;

    MarketplaceStock({ marketplaceParams, tenantId }: any): any;

    MintingStatus(...args: any[]): void;

    NFT({ tokenId, contractAddress }: any): any;

    NFTContractStats({ contractAddress }: any): any;

    Notifications({ tenantId, types, offsetId, limit = 10 }: any): any;

    PackOpenStatus({ contractAddress, tokenId }: any): any;

    PersonalSign(...args: any[]): void;

    Profile({ userAddress, userName }: any): any;

    ProfileMetadata({ type = "app", mode = "public", appId, userAddress, key }: any): any;

    PurchaseItem({ marketplaceParams, sku, confirmationId, successUrl, cancelUrl }: any): void;

    PurchaseListing({ marketplaceParams, listingId, confirmationId, successUrl, cancelUrl }: any): void;

    PurchaseStatus({ marketplaceParams, confirmationId }: any): any;

    PushNotification({ tenantId, eventType, data, userAddress }: any): void;

    RedeemableCustomFulfillmentInfo({ redeemableTransactionId }: any): any;

    RedeemableOfferStatus({ tenantId, marketplaceParams, contractAddress, tokenId, offerId }: any): any;

    RejectMarketplaceOffer({ offerId }: any): any;

    RemoveListing({ listingId }: any): void;

    RemoveMarketplaceOffer({ offerId }: any): any;

    RemoveProfileMetadata({ type = "app", mode = "public", appId, key }: any): void;

    RevokeVote({ tenantId, votingEventId, sku }: any): any;

    Sales(...args: any[]): any;

    SalesNames({ marketplaceParams }: any): any;

    SalesStats(...args: any[]): any;

    SetAuthorization({
                       clusterToken,
                       fabricToken,
                       tenantId,
                       address,
                       email,
                       expiresAt,
                       signerURIs,
                       walletType,
                       walletName,
                       nonce,
                       register = false
                     }: {
                       clusterToken?: string,
                       fabricToken?: string,
                       tenantId?: string,
                       address?: string,
                       email?: string,
                       expiresAt?: string,
                       signerURIs?: string,
                       walletType?: string,
                       walletName?: string,
                       nonce?: string,
                       register?: boolean
                     }
    ): void;

    SetCodeAuth(...args: any[]): void;

    SetProfileMetadata({ type = "app", mode = "public", appId, key, value }: any): void;

    SignMetamask(...args: any[]): void;

    SubmitDropVote({ marketplaceParams, eventId, dropId, sku }: any): void;

    TenantCSS({ tenantSlug }: any): any;

    TenantConfiguration({ tenantId, contractAddress }: any): any;

    TokenStatus(...args: any[]): void;

    TransferNFT({ contractAddress, tokenId, targetAddress }: any): any;

    Transfers(...args: any[]): any;

    UserAddress(): any;

    UserInfo(): any;

    UserItemAttributes({ marketplaceParams, displayName, userAddress }: any): any;

    UserItemEditionNames({ displayName }: any): any;

    UserItemNames({ marketplaceParams, userAddress }: any): any;

    UserItems({ sortBy = "default", includeFullMetadata = false }: any, ...args: any[]): any;

    UserListings({
                   userAddress,
                   sortBy = "created",
                   sortDesc = false,
                   contractAddress,
                   tokenId,
                   marketplaceParams
                 }: any): any;

    UserNameToAddress({ userName }: any): any;

    UserSales({
                userAddress,
                sortBy = "created",
                sortDesc = false,
                contractAddress,
                tokenId,
                startTime,
                endTime,
                lastNDays,
                marketplaceParams
              }: any): any;

    UserTransfers({
                    userAddress,
                    sortBy = "created",
                    sortDesc = false,
                    contractAddress,
                    tokenId,
                    startTime,
                    endTime,
                    lastNDays,
                    marketplaceParams
                  }: any): any;

    UserWalletBalance(checkOnboard: any): any;

    VoteStatus({ tenantId, votingEventId }: any): any;

    static AllowedMethods(...args: any[]): void;

    static ForbiddenMethods(...args: any[]): void;

    static Initialize(...args: any[]): Promise<ElvWalletClient>;

  }

  export namespace Utils {
    const PLATFORM_NODE: string;

    const PLATFORM_REACT_NATIVE: string;

    const PLATFORM_WEB: string;

    const name: string;

    const nullAddress: string;

    function AddressToHash(address: string, key?: boolean): string;

    function AddressToLibraryId(address: any): any;

    function AddressToNodeId(address: any): any;

    function AddressToObjectId(address: any): any;

    function AddressToSpaceId(address: any): any;

    function B58(arr: any): any;

    function B64(str: any, encoding: any): any;

    function BufferToArrayBuffer(buffer: any): any;

    function DecodeAuthorizationToken(token: any): any;

    function DecodeSignedToken(token: any): any;

    function DecodeVersionHash(versionHash: any): any;

    function DecodeWriteToken(writeToken: any): any;

    function EqualAddress(...args: any[]): void;

    function EqualHash(...args: any[]): void;

    function EtherToWei(ether: any): any;

    function FormatAddress(address: any): any;

    function FormatSignature(sig: any): any;

    function FromB58(str: any): any;

    function FromB58ToStr(str: any): any;

    function FromB64(str: any): any;

    function FromB64URL(str: any): any;

    function FromHex(str: any): any;

    function HLSJSSettings({}: { profile?: string }): object;

    function HashToAddress(hash: any, key: any): any;

    function IsCloneable(value: any): any;

    function LimitedMap(limit: any, array: any, f: any): any;

    function LiveHLSJSSettings(...args: any[]): void;

    function MakeClonable(value: any): any;

    function Platform(): any;

    function PublicKeyToAddress(key: any): any;

    function ResizeImage({}: { imageUrl?: string, height: number }): string | undefined;

    function ResponseToFormat(format: any, response: any, debug: any, logFn: any): any;

    function ResponseToJson(response: any, debug: any, logFn: any): any;

    function SafeTraverse(...args: any[]): void;

    function ToBigNumber(value: any): any;

    function ToBytes32(string: any): any;

    function ValidAddress(address: any): any;

    function ValidHash(hash: any): any;

    function WeiToEther(wei: any): any;

    namespace weiPerEther {
      const c: number[];

      const e: number;

      const s: number;

      function abs(): any;

      function absoluteValue(): any;

      function comparedTo(y: any, b: any): any;

      function decimalPlaces(dp: any, rm: any): any;

      function div(y: any, b: any): any;

      function dividedBy(y: any, b: any): any;

      function dividedToIntegerBy(y: any, b: any): any;

      function dp(dp: any, rm: any): any;

      function eq(y: any, b: any): any;

      function exponentiatedBy(n: any, m: any): any;

      function gt(y: any, b: any): any;

      function gte(y: any, b: any): any;

      function idiv(y: any, b: any): any;

      function integerValue(rm: any): any;

      function isEqualTo(y: any, b: any): any;

      function isFinite(): any;

      function isGreaterThan(y: any, b: any): any;

      function isGreaterThanOrEqualTo(y: any, b: any): any;

      function isInteger(): any;

      function isLessThan(y: any, b: any): any;

      function isLessThanOrEqualTo(y: any, b: any): any;

      function isNaN(): any;

      function isNegative(): any;

      function isPositive(): any;

      function isZero(): any;

      function lt(y: any, b: any): any;

      function lte(y: any, b: any): any;

      function minus(y: any, b: any): any;

      function mod(y: any, b: any): any;

      function modulo(y: any, b: any): any;

      function multipliedBy(y: any, b: any): any;

      function negated(): any;

      function plus(y: any, b: any): any;

      function pow(n: any, m: any): any;

      function precision(sd: any, rm: any): any;

      function sd(sd: any, rm: any): any;

      function shiftedBy(k: any): any;

      function sqrt(): any;

      function squareRoot(): any;

      function times(y: any, b: any): any;

      function toExponential(dp: any, rm: any): any;

      function toFixed(dp: any, rm: any): any;

      function toFormat(dp: any, rm: any, format: any): any;

      function toFraction(md: any): any;

      function toJSON(): any;

      function toNumber(): any;

      function toPrecision(sd: any, rm: any): any;

      function toString(b: any): any;

      function valueOf(): any;

    }
  }
}

